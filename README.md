# Описание
AI анализ свободных ответов опроса 

<!---# Выбор имён
Возможно 2 подхода к выделению отдельных персоналий:
 - сопоставление с заранее подготовленным списком имён
 - формирование списка имён по обрабатываемому файлу

Пусть у нас уже сформирован список имён. Тогда обрабатываемое имя может соответствовать имени из списка, если оно является частью имени из списка. Для неидентифицированных имён можно сделать список кандидатов, но это уже дополнительно. 


# Структура хранения
Excel таблица считывается в DataFrame, который затем делится на 3 части, которые обрабатываются отдельно. Для каждой таблицы нужен будет DataFrame, в который будут складываться неидентифицированные строки. Можно будет сделать так, чтобы после правок они дообрабатывались и добавлялись в статистику к уже обработанным.

Для обработки полей с фиксированным ответом будет формироваться вложенный словарь, в котором вопросам будут сопоставляться ответы, а ответам ключи.  

Промежуточные результаты удобно будет хранить в словаре, где ключ - имя, а значение - по сути json т.е. словарь в котором названия вопросов 

Итог: 
- Исходный ```DataFrame``` 
- Выборки столбцов из исходного ```DataFrame```'ы для обработки отдельных типов руководства
- Выборки строк, для которых имя не идентифицированно для отдельных типов руководства
- Промежуточные аккумулирующие структуры для сбора статистики по персоналиям относительно каждого типа руководства
- Итоговый ```DataFrame```    

Дополнительные структуры:
- Множество имён
    - Конструктор, принимающий имя файла
    - Проверка на наличие имени и уникальности: -> Optional[str]

- Множество ответов
    - Конструктор, принимающий имя файла 
    - Найти ответ

- Множество 
-->
# Необходимые структуры
Для обработки таблицы неплохо было бы создать JSON с описанием полей, и групп:
```
{
    "fields" : {
        "номер поля 1" : [
            "тип поля 1", 
            "имя поля 1", 
            {
                "ответ 1" : "интерпретация 1", 
                "ответ 2" : интерпретация 2"
            }
        ],
        "номер поля 2" : [
            "тип поля 2", 
            "имя поля 2"
        ],
        ...
        "номер поля n" : [
            "тип поля n", 
            "имя поля n", 
            {
                "ответ 1" : "интерпретация 1", 
                "ответ 2" : интерпретация 2"
            }
        ]
    },

    "groups" : {
        "имя группы 1" : [
            1,
            2,
            5,
            ...
            4
        ],
        ...
        "имя группы n" : [
            17,
            19,
            3,
            ...
            6
        ]
    }

    "merge" : {
        "результирующее поле 1" : [
            1,
            17,
            ...
            9
        ]
        ...
    }
}
```

Для удобства мы нумнеруем вопросы, чтобы дальше использовать их номера, а не их полную формулировку. Фактически мы создаём словарь, где ключом будет номер, а значением - список параметров. Для каждого номера мы определяем тип и формулировку вопроса. После этого могут идти дополнительная информация. У нас такая информация необходима для вопросов с выбором ответа и галочек.    
 

Для классификации полей можно использовать следующие типы:
- ```check``` - галочка, которая говорит о том, следует ли обрабатывать вопросы этой группы (опционально - ограничить одной на группу)
    - в дополнительной информации будет словарь ответов, где по формулировка ответа будет ключом, а значением - 0 или 1.     
- ```name``` - имя оцениваемого человека (опционально - ограничить одним на группу)
- ```select``` - вопрос с выбором ответа
    - в дополнительной информации будет словарь ответов, где по формулировка ответа будет ключом, а интерпретация - значением.     
- ```number``` - вопрос со вводом числа
- ```free``` - вопрос со свободным ответом т.е. обратная связь

Поскольку части таблицы могут собирать статистику для разных людей, то имеет смысл разделить обработку этих частей. Для этого создадим словарь ```groups```, где каждой именованной группе будем сопоставлять список полей этой группы. Так как группа должна быть объединена на основе одного ключевого поля, то имеет смысл проверять группу на корректность. Для галочек такое ограничение не обязательно.

Поскольку при объединении групп в общую таблицу может понадобиться общая статистика для полей из разных групп, то можно добавить словарь ```merge```, в котором будет указываться название нового поля и то, какие поля оно объединяет.  

Первоначально для каждой группы можно сделать две таблички - отчётную и со строками, в которых не удалось идентифицировать имена (опционально - дополнение отчётной таблички после правки необработанных имён).  

Для хранения промежуточных результатов можно использовать следующую структуру (назовём её ```collector```):    
```
{
    "name 1" : {
        "question 1" : mini_collector< T1 >,
        "question 2" : mini_collector< T2 >,
        ...
        "question n" : mini_collector< T1 >
    },
    ...
    "name m" : {
        "question 1" : mini_collector< T4 >,
        "question 2" : mini_collector< T4 >,
        ...
        "question n" : mini_collector< T5 >
    }
}
```

Формат хранения ответов на вопросы в ```mini_collector< T >``` будет зависеть от его типа ```T```:
- ```select``` - счётчики по вариантам ответов и общий счётчик 
    - в данном случае под вариантами ответов будут подразумеваться те ответы, которые получаются после расшифровки т.е. в нашем случае позитивная оценка/негативная оценка
- ```number``` - сумма по всем ответам и общий счётчик
- ```free``` - полный список сырых ответов на вопрос

Для типа ```name``` можно создать некоторую структуру ```name_dict```, которая будет являться словарём, в котором по набору токенов, на которые разбивается входная строка, будет выдаваться строка с именем. Все имена будут храниться в каком-то файле. Он может быть получен либо в результате анализа всех полей типа ```name```, либо подготовлен заранее.  

<!--Поскольку каждый ```collector``` напрямую связан с отдельной группой, то имеет смысл учитывать это при создании класса. Тогда можно делать обрабатываему часть ```DataFrame``` полем класса. Для последующей обработки имеет смысл проверить корректность группы и переупорядочить поля так, чтобы первым было имя, вторым   Для инициализации ```mini_collector```'ов нужно узнать тип вопроса, для этого идём ```survey_structure``` и по switch'у создаём их.

Процесс обработки строки:
1. идентификация т.е. проверка имени и флажка 
2. проходимся по вопросам


При обработке опроса просто отправляем значение поля в ```mini_collector```.

Класс должен на выходе создавать 2 сущности: таблицу обработанных данных и таблицу необработанных данных.



-->
 


# Процесс обработки

Предварительно имеет смысл проверить JSON на корректность структуры по части ```groups``` и ```merge```.

1. Читаем табличку в ```DataFrame```
2. Создаём общие ```name_dict``` и  ```survey_structure```
3. Разбиваем ```DataFrame``` на группы столбцов в соответствии с типом руководства, и для каждой группы создаём ```collector```, в котором будем собирать данные по столбцам
    - По списку полей в группе создаётся ```survey_substructure```, в которой будет храниться необходимая часть полей для данной группы
    - Определяются номера полей типа ```name``` и ```check```  
    - Переупорядочиваются поля так, чтобы первыми были ```check```, зачем ```name```, а потом остальные
    - Построчно анализируются идентифицированные персоналии, те кого не удалось идентиифицировать добавляются в соответствующую таблицу
4. Объединение ```collector``` в общий ```DataFrame``` 
    - ```collector```'ы различных групп объединяются в общий, в который добавляются поля из ```merge```
    - формируем ```DataFrame``` по столбцам
    - если какой-то столбец преобразуется в несколько, то добавляем стандартные для типа постфиксы
5. Из итогового ```DataFrame``` собираются ответы на "Общий отчёт"
 

<!--Жду комментариев.-->






    
        